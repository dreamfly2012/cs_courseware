/*  --------------------------------

       温度测量程序（C51）. JiLin University

	   Copyright 2010. zhu liang All Rights Reserved.

	   ------------------------------  */

#include "reg52.h"
#include "intrins.h"
#define uchar unsigned char
#define uint unsigned int
// 引入汇编延时程序
extern void delay1(uint);   
// 单片机输出端口定义区
sbit P11 = 0x91;
sbit P12 = 0x92;
sbit hot = 0x93;
sbit ds = 0x94;
sbit hot_key = 0xB6;
// 数据定义区
data uchar flag;
data uchar dispram[3];
// LED数码管显示程序
void display()
{
	data uchar led_dis[] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};
	data uchar led_dis1[] = {0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10};
	data uchar i = 0;
	data uchar temp = 0x80;
	data uchar dis[3];
	P12 = 0;
	
	dis[0] = led_dis[dispram[0]];
	dis[1] = led_dis1[dispram[1]];
	dis[2] = led_dis[dispram[2]];

	for(i=0;i<8;i++)
	{
		if(dis[0]&temp)
			P11 = 1;
		else
			P11 = 0;
		P12 = 1;		
		P12 = 0;		
		temp=temp>>1;
	}
    temp = 0x80;
	for(i=0;i<8;i++)
	{
		if(dis[1]&temp)
			P11 = 1;
		else
			P11 = 0;
		P12 = 1;		
		P12 = 0;		
		temp=temp>>1;
	}
    temp = 0x80;
	for(i=0;i<8;i++)
	{
		if(dis[2]&temp)
			P11 = 1;
		else
			P11 = 0;
		P12 = 1;	
		P12 = 0;
		temp=temp>>1;
	}
}		
// 延时程序
void TempDelay(uchar us)
{
	while(us--);
}
void delay(uint count)
{
	uint i;
	while(count)
	{
		i = 200;
		while(i>1)
			i--;
		count--;
	}
}
//串口初始化，波特率9600，方式1 
void init_com()
{
   TMOD=0x20;      //设置定时器1为模式2
   TH1=0xfd;       //装初值设定波特率
   TL1=0xfd;
   TR1=1;          //启动定时器
   SM0=0;          //串口通信模式设置
   SM1=1;
// REN=1;          //串口允许接收数据
   PCON=0;         //波特率不倍频
// SMOD=0;       //波特率不倍频
// EA=1;          //开总中断
// ES=1;          //开串行中断
}

void ds_reset(void)
{
	ds=1;
	_nop_();        //1us
	ds=0;
	TempDelay(80);  //当总线停留在低电平超过500us，总线上所以器件都将被复位，这里延时约530us
	_nop_(); 
	ds=1;           //产生复位脉冲后，微处理器释放总线,让总线处于空闲状态

	TempDelay(5);   //释放总线后，以便从机18b20通过拉低总线来指示其是否在线,
                   //存在检测高电平时间：15~60us， 所以延时44us
	_nop_();
	_nop_();
	_nop_();
	if(ds==0)
        flag=1;       //detect 18b20 success
	else
        flag=0;       //detect 18b20 fail
	TempDelay(20);    //存在检测低电平时间：60~240us，所以延时约140us
	_nop_();
	_nop_();
	ds=1;          //再次拉高总线，让总线处于空闲状态
}

/*----------------------------------------
读/写时间隙:
DS1820 的数据读写是通过时间隙处理
位和命令字来确认信息交换。
------------------------------------------*/
bit ds_read_bit(void)    //读一位
{
	bit dat;
	ds=0;				//单片机（微处理器）将总线拉低
	_nop_();			//读时隙起始于微处理器将总线拉低至少1us
	ds=1;				//拉低总线后接着释放总线，让从机18b20能够接管总线，输出有效数据
	_nop_();
	_nop_();			//小延时一下，读取18b20上的数据 ,因为从ds18b20上输出的数据
	//在读"时间隙"下降沿出现15us内有效
	dat=ds;				//主机读从机18b20输出的数据，这些数据在读时隙的下降沿出现//15us内有效 
	TempDelay(10);		//所有读"时间隙"必须60~120us，这里77us
	return(dat);		//返回有效数据
}
uchar ds_read_byte(void ) //读一字节
{
	uchar value,i,j;
	value=0;           //一定别忘了给初值
	for(i=0;i<8;i++)
	{
		j=ds_read_bit();
		value=(j<<7)|(value>>1);  //从高位到低位依次读出
	}
	return(value);        //返回一个字节的数据
}
void ds_write_byte(uchar dat) //写一个字节
{
	uchar i;
	bit onebit;        
	for(i=1;i<=8;i++) 
	{
		onebit=dat&0x01;
		dat=dat>>1;
		if(onebit)			//写 1
		{
			ds=0;
			_nop_();    
			_nop_();		//看时序图，至少延时1us，才产生写"时间隙" 
			ds=1;			//写时间隙开始后的15μs内允许数据线拉到高电平
			TempDelay(5);	//所有写时间隙必须最少持续60us
		}
		else				//写 0
		{
			ds=0;
			TempDelay(8);   //主机要生成一个写0 时间隙，必须把数据线拉到低电平并保持至少60μs，这里64us
			ds=1;
			_nop_();
			_nop_();
		}
	}
}



void tem_change()
{
	ds_reset(); 
	delay(1);				// 约2ms
	//delay1(20);
	ds_write_byte(0xcc);	// Skip ROM
	ds_write_byte(0x44);	// Convert Temperature
}

/*----------------------------------------
获得温度
------------------------------------------*/
void get_temperature()
{
	data uint temp;
	float wendu;
	uchar a,b;
	ds_reset();
	delay(1);				//约2ms
	ds_write_byte(0xcc);
	ds_write_byte(0xbe);
	a=ds_read_byte();		// Low byte
	b=ds_read_byte();		// High byte
	temp=b;
	temp<<=8;
	temp=temp|a;
	wendu=temp*0.0625;     //得到真实十进制温度值，因为DS18B20
                           //可以精确到0.0625度，所以读回数据的最低位代表的是0.0625度
	temp=wendu*10+0.5;     //放大十倍，这样做的目的将小数点后第一位
                           //也转换为可显示数字，同时进行一个四舍五入操作。
	dispram[0] = (uchar) (temp % 10);   
    temp /= 10;   
    dispram[1] = (uchar) (temp % 10);
    temp /=10;   
    dispram[2] = (uchar) (temp % 10);  	
}
void main()
{
	init_com();
	while(1)
	{
	   P0 = hot_key;
	   hot = ~hot_key;
		tem_change();          //12位转换时间最大为750ms
		get_temperature();
		display();
		delay1(10000);
   }
}