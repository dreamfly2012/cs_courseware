/****************************************************************************
* 文 件 名：main.c
* 功    能：使用ADC模块的通道0、1进行电压的测量，然后将转换结果从串口输出，
*           上位机使用EasyARM软件全仿真的DOS字符窗口观察。
* 说    明：跳线JP8、JP30短接。由W1、W2调节测量电压值。
*           通讯格式：8位数据位，1位停止位，无奇偶校验，波特率为115200。
****************************************************************************/
#include  "config.h"
#include  "stdio.h"


#define UART_BPS 115200
const uint8 SHOWTABLE[16]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};


/****************************************************************************
* 名    称：DelayNS()
* 功    能：长软件延时
* 入口参数：dly		延时参数，值越大，延时越久
* 出口参数：无
****************************************************************************/
void  DelayNS(uint32  dly)
{   uint32  i;
    for(; dly>0; dly--) 
    {
        for(i=0; i<5000; i++);
    }
}

/****************************************************************************
* 名    称：UART0Init()
* 功    能：初始化串口0。设置为8位数据位，1位停止位，无奇偶校验
* 入口参数：bps 通讯波特率 
* 出口参数：无
****************************************************************************/
void  UART0Init(uint32 bps)
{   uint16 Fdiv;

    PINSEL0 = (PINSEL0 & (~0x0F)) | 0x05;	// 不影响其它管脚连接,设置I/O连接到UART0
    U0LCR = 0x83;							// DLAB = 1，可设置波特率
    Fdiv = (Fpclk / 16) / bps;				// 设置波特率
    U0DLM = Fdiv / 256;							
    U0DLL = Fdiv % 256;						
    U0LCR = 0x03;
}

/****************************************************************************
* 名    称：UART0SendByte()
* 功    能：向串口发送字节数据，并等待发送完毕。
* 入口参数：data  要发送的数据
* 出口参数：无
****************************************************************************/
/*void  UART0SendByte(uint8 data)
{  
    U0THR = data;							// 发送数据
    while( (U0LSR&0x40)==0 );				// 等待数据发送完毕
}
*/

void  SendByte(uint8 data)
{  
    U0THR = data;							// 发送数据
    while( (U0LSR&0x40)==0 );				// 等待数据发送完毕
}

/****************************************************************************
* 名    称：UART0SendStr()
* 功    能：向串口发送一字符串
* 入口参数：srt		要发送的字符串的指针
* 出口参数：无
****************************************************************************/
/*void  UART0SendStr(char *str)
{  
    while(1)
    {  
        if( *str == '\0' ) break;
        UART0SendByte(*str++);				// 发送数据
    }
}
*/
/****************************************************************************
* 名    称：PCDispChar()
* 功    能：向PC机发送显示字符。
* 入口参数：x        显示位置的纵坐标，0-79   
*           y        显示位置的横坐标，0-24 
*           chr      显示的字符，不能为0xff
*           color    显示的状态包括前景色、背景色、闪耀位。它与dos的字符显示状态一样。 
*                   即0~3位：前景色，4~6位：背景色，7位：闪耀位。
* 出口参数：无
****************************************************************************/
/*
void  PCDispChar(uint8 x, uint8 y, uint8 chr, uint8 color)
{  
    UART0SendByte(0xff);				    // 发送起始字节
    UART0SendByte(x);						// 发送字符显示坐标(x,y)
    UART0SendByte(y);
    UART0SendByte(chr);						// 发送显示字符
    UART0SendByte(color);			
}
*/
/****************************************************************************
* 名    称：ISendStr()
* 功    能：向PC机发送字串，以便显示。
* 入口参数：x        显示位置的纵坐标，0-79   
*           y        显示位置的横坐标，0-24 
*           color    显示的状态包括前景色、背景色、闪耀位。它与dos的字符显示状态一样。 
*                   即0~3位：前景色，4~6位：背景色，7位：闪耀位。
*           str      要发送的字符串，字串以'\0'结束
* 出口参数：无
****************************************************************************/
/*
void  ISendStr(uint8 x, uint8 y, uint8 color, char *str)
{  
    while(1)
    {  
        if(*str=='\0') break;                    // 若为'\0'，则退出
        PCDispChar(x++, y, *str++, color);       // 发送显示数据
        if(x>=80)
        {  
            x = 0;
            y++;
        }
    }
} 

void ISendByte(uint8 data)
{
  U0THR=data;
  while((U0LSR&0x40)==0);  
}
*/
void ISendBuf(uint8 const *buf,uint8 no)
{
   uint8 i;
   for(i=0;i<no;i++)
   {
      SendByte(buf[i]);
   }
}

void Data_disp(uint32 Data)
{
  uint8 LED_MODE[5]={0xff,0x80,0x00,0x00,0x00};
  uint8 data_buf[8];
  uint32 data;
  uint8 bak;
  uint8 i;
  data=Data;
  for(i=0;i<8;i++)
  {
     bak=(data>>i*4)&0x0F;
     data_buf[i]=SHOWTABLE[bak];
  }

  for(i=0;i<8;i++)
  {
     LED_MODE[2]=i;
     LED_MODE[3]=data_buf[i];
     ISendBuf(LED_MODE,5);
  
  }
}

/****************************************************************************
* 名    称：main()
* 功    能：进行通道0、1电压ADC转换，并把结果转换成电压值，然后发送到串口。
* 说    明：在CONFIG.H文件中包含stdio.h。
****************************************************************************/
int  main(void)
{  
    uint32  ADC_Data;
    
    UART0Init(115200);							// 初始化UART0
    PINSEL1 =1<<24;						        // 设置P0.28为AIN1 
   
    /* 进行ADC模块设置，其中x<<n表示第n位设置为x(若x超过一位，则向高位顺延) */
    ADCR = (1 << 1)                     |		// SEL = 1 ，选择通道1
           ((Fpclk / 2000000 - 1) << 8) | 		// CLKDIV = Fpclk / 1000000 - 1 ，即转换时钟为1MHz
           (0 << 16)                    |		// BURST = 0 ，软件控制转换操作
           (0 << 17)                    | 		// CLKS = 0 ，使用11clock转换
           (1 << 21)                    | 		// PDN = 1 ， 正常工作模式(非掉电转换模式)
           (0 << 22)                    | 		// TEST1:0 = 00 ，正常工作模式(非测试模式)
           (1 << 24)                    | 		// START = 1 ，直接启动ADC转换
           (0 << 27);							// EDGE = 0 (CAP/MAT引脚下降沿触发ADC转换)
    DelayNS(10);								
    ADC_Data = ADDR;							// 读取ADC结果，并清除DONE标志位
   
    while(1)
    {  
        ADCR = (ADCR&0x00FFFF00)|0x02|(1 << 24);	// 设置通道1，并进行第一次转换
        while( (ADDR&0x80000000)==0 );	            // 等待转换结束
        ADCR = ADCR | (1 << 24);					// 再次启运转换
        while( (ADDR&0x80000000)==0 );              // 等待转换结束
        ADC_Data = ADDR;							// 读取ADC结果
        ADC_Data = (ADC_Data>>6) & 0x3FF;           // 提取AD转换值
        ADC_Data = ADC_Data * 3300;                 // 数值转换
        ADC_Data = ADC_Data / 1024;
        Data_disp(ADC_Data);          
        DelayNS(10);        
    }

    return(0);
}
